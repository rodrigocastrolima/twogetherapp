# TwogetherApp Project Rules & Context

## Project Overview

TwogetherApp is a Flutter application for managing renewable energy offerings with a focus on the sales process. It provides a platform for administrators and resellers to manage clients, track sales opportunities, and integrate with Salesforce for data synchronization.

### Core Purpose

- Facilitate management of renewable energy sales and offerings
- Provide different interfaces for administrators and resellers
- Maintain seamless synchronization with Salesforce
- Ensure secure user management and authentication

## Architecture Guidelines

TwogetherApp follows Clean Architecture principles with a clear separation of concerns:

### Domain Layer

- Contains core business entities, use cases, and repository interfaces
- Models like `AppUser` define fundamental data structures
- Uses Freezed for immutable model classes
- Repository interfaces define abstract methods to be implemented by data layer

### Data Layer

- Implements repositories and services for external data access
- Firebase service implementations for auth, database, and cloud functions
- Salesforce integration services for data synchronization
- Handles external API interactions and data persistence

### Presentation Layer

- Contains UI components and state management
- Uses Flutter Riverpod for state management
- Implements responsive UI layouts for different screen sizes
- Separates UI widgets from business logic

### Infrastructure Layer

- Backend services via Firebase Cloud Functions
- Handles secure operations like user creation and management
- Provides integration points with Salesforce
- Implements data validation and security rules

## Key Components Reference

### Authentication System

- Located primarily in `lib/features/auth/`
- Implements Firebase Authentication for email/password login
- Supports role-based access control with three main roles:
  - `admin`: Full system access with user management capabilities
  - `reseller`: Limited access focused on client management and sales
  - `unknown`: Default role for unauthenticated users
- Handles session management with web-specific configurations

### User Management

- Main implementation in `lib/features/user_management/presentation/pages/user_management_page.dart`
- Features:
  - Creating new users with role assignment
  - Enabling/disabling existing users
  - Resetting user passwords
  - Detailed user information display and editing
- Uses Cloud Functions for secure user operations to avoid disrupting admin sessions

### Salesforce Integration

- Located in `lib/features/salesforce/`
- Bidirectional sync between Firebase and Firestore
- Key components:
  - `salesforce_connection_service.dart`: Handles API authentication and requests
  - `salesforce_user_sync_service.dart`: Synchronizes user data between systems
- User creation can be initiated from Salesforce IDs to maintain data consistency
- Uses JWT authentication for secure Salesforce API access

### Firebase Cloud Functions

- Located in `functions/src/`
- Key functions:
  - `createUser`: Creates new users in Firebase Auth and Firestore
  - `setUserEnabled`: Enables or disables user accounts
  - `ping`: Tests connectivity to Firebase Functions
  - `syncUserWithSalesforce`: Synchronizes user data with Salesforce
  - `getSalesforceAccessToken`: Handles JWT authentication with Salesforce

### Support Scripts

- Organized in the `scripts/` directory:
  - `scripts/firebase/testing/`: Scripts for testing Firebase Functions
  - `scripts/firebase/deployment/`: Scripts for verifying deployment
  - `scripts/salesforce/`: Scripts for Salesforce integration testing

## Data Flow & Critical Processes

### User Creation Process

1. Admin initiates user creation from the UI (`user_management_page.dart`)
2. Request is sent to Firebase Functions (`firebase_functions_service.dart`)
3. Cloud Function validates admin permissions
4. If Salesforce ID is provided:
   - Cloud Function verifies the ID exists in Salesforce
   - Retrieves user details from Salesforce
   - Creates Firebase Auth account
   - Creates Firestore document with mapped Salesforce fields
5. User receives notification for account creation

### Salesforce Synchronization

1. Sync can be initiated manually or automatically
2. Firebase Function calls Salesforce API with JWT authentication
3. Data is mapped between systems using predefined field mappings:
   - `Id` → `salesforceId`
   - `Name` → `displayName`
   - `FirstName` → `firstName`
   - `LastName` → `lastName`
   - `Email` → `email`
   - `Phone` → `phoneNumber`
   - `MobilePhone` → `mobilePhone`
   - `Department` → `department`
   - `IsActive` → `isActive`
   - `LastLoginDate` → `lastSalesforceLoginDate`
   - `Username` → `salesforceUsername`
   - `Revendedor_Retail__c` → `revendedorRetail`
4. Firestore documents are updated with Salesforce data
5. Changes in Firebase can be pushed back to Salesforce

## Best Practices & Conventions

### Code Structure

- Place new features in the `lib/features/` directory
- Maintain separation between domain, data, and presentation layers
- Use repository pattern for data access
- Follow the existing naming conventions in each module

### State Management

- Use Riverpod for state management
- Create dedicated providers for different features
- Follow the pattern of separating state, notifier, and provider

### Error Handling

- Use try-catch blocks for operations that may fail
- Display user-friendly error messages
- Log detailed errors for debugging
- Handle network errors gracefully

### Testing

- Use the testing scripts in the `scripts/` directory
- Test Firebase Functions individually before integration
- Verify Salesforce sync with test scripts before deployment
- Use the Firebase Emulator for local testing

## Common Issues & Solutions

### Firebase Functions

- If functions aren't accessible, verify deployment with `firebase functions:list`
- For permission issues, check admin rights in Firestore
- For Salesforce connection issues, verify the JWT authentication is working

### User Management

- If user creation fails, check Cloud Function logs
- For authentication issues, verify the admin token hasn't expired
- If Salesforce sync fails, check if the Salesforce ID exists and is valid

### Salesforce Integration

- For authentication issues, verify the JWT token generation
- If field mapping fails, check if field names match the Salesforce schema
- For sync failures, verify network connectivity and API permissions

## Development Workflow

### Local Development

- Run the Flutter app with Firebase Emulator
- Test Cloud Functions locally before deployment
- Use the testing scripts to verify functionality

### Deployment Process

1. Test all functionality locally
2. Deploy Firebase Functions first: `firebase deploy --only functions`
3. Verify functions with the check scripts
4. Build and deploy the Flutter app
5. Run post-deployment verification tests

## Project Roadmap & Future Enhancements

### High Priority

- Refactor the large `index.ts` file in Firebase Functions
- Improve error handling in the user creation process
- Enhance testing coverage for critical flows

### Medium Priority

- Optimize large files like `user_management_page.dart`
- Implement pagination for large data sets
- Enhance offline capabilities

### Long-term Goals

- Add more analytics features
- Enhance reporting capabilities
- Improve user experience for mobile devices

## Appendix: Key Files Reference

- `lib/features/auth/domain/models/app_user.dart`: Core user model
- `lib/features/auth/data/services/firebase_functions_service.dart`: Cloud Functions client
- `lib/features/salesforce/data/services/salesforce_user_sync_service.dart`: Salesforce sync service
- `lib/features/user_management/presentation/pages/user_management_page.dart`: Admin UI for user management
- `functions/src/index.ts`: Firebase Cloud Functions implementation 